Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    AMPM

Grammar

Rule 0     S' -> start
Rule 1     start -> LINUX
Rule 2     start -> cpu
Rule 3     start -> all
Rule 4     start -> empty
Rule 5     start -> data
Rule 6     start -> date
Rule 7     start -> DATE
Rule 8     time -> INTEGER : INTEGER
Rule 9     date -> INTEGER / INTEGER / INTEGER time
Rule 10    cpu -> time CPU
Rule 11    all -> time ALL
Rule 12    data -> time INTEGER float float float float float float float float float
Rule 13    float -> INTEGER . INTEGER
Rule 14    empty -> <empty>

Terminals, with rules where they appear

.                    : 13
/                    : 9 9
:                    : 8
ALL                  : 11
AMPM                 : 
CPU                  : 10
DATE                 : 7
INTEGER              : 8 8 9 9 9 12 13 13
LINUX                : 1
error                : 

Nonterminals, with rules where they appear

all                  : 3
cpu                  : 2
data                 : 5
date                 : 6
empty                : 4
float                : 12 12 12 12 12 12 12 12 12
start                : 0
time                 : 9 10 11 12

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . LINUX
    (2) start -> . cpu
    (3) start -> . all
    (4) start -> . empty
    (5) start -> . data
    (6) start -> . date
    (7) start -> . DATE
    (10) cpu -> . time CPU
    (11) all -> . time ALL
    (14) empty -> .
    (12) data -> . time INTEGER float float float float float float float float float
    (9) date -> . INTEGER / INTEGER / INTEGER time
    (8) time -> . INTEGER : INTEGER

    LINUX           shift and go to state 5
    DATE            shift and go to state 2
    $end            reduce using rule 14 (empty -> .)
    INTEGER         shift and go to state 7

    all                            shift and go to state 1
    start                          shift and go to state 4
    time                           shift and go to state 3
    date                           shift and go to state 6
    data                           shift and go to state 8
    cpu                            shift and go to state 9
    empty                          shift and go to state 10

state 1

    (3) start -> all .

    $end            reduce using rule 3 (start -> all .)


state 2

    (7) start -> DATE .

    $end            reduce using rule 7 (start -> DATE .)


state 3

    (10) cpu -> time . CPU
    (11) all -> time . ALL
    (12) data -> time . INTEGER float float float float float float float float float

    CPU             shift and go to state 13
    ALL             shift and go to state 12
    INTEGER         shift and go to state 11


state 4

    (0) S' -> start .



state 5

    (1) start -> LINUX .

    $end            reduce using rule 1 (start -> LINUX .)


state 6

    (6) start -> date .

    $end            reduce using rule 6 (start -> date .)


state 7

    (9) date -> INTEGER . / INTEGER / INTEGER time
    (8) time -> INTEGER . : INTEGER

    /               shift and go to state 15
    :               shift and go to state 14


state 8

    (5) start -> data .

    $end            reduce using rule 5 (start -> data .)


state 9

    (2) start -> cpu .

    $end            reduce using rule 2 (start -> cpu .)


state 10

    (4) start -> empty .

    $end            reduce using rule 4 (start -> empty .)


state 11

    (12) data -> time INTEGER . float float float float float float float float float
    (13) float -> . INTEGER . INTEGER

    INTEGER         shift and go to state 16

    float                          shift and go to state 17

state 12

    (11) all -> time ALL .

    $end            reduce using rule 11 (all -> time ALL .)


state 13

    (10) cpu -> time CPU .

    $end            reduce using rule 10 (cpu -> time CPU .)


state 14

    (8) time -> INTEGER : . INTEGER

    INTEGER         shift and go to state 18


state 15

    (9) date -> INTEGER / . INTEGER / INTEGER time

    INTEGER         shift and go to state 19


state 16

    (13) float -> INTEGER . . INTEGER

    .               shift and go to state 20


state 17

    (12) data -> time INTEGER float . float float float float float float float float
    (13) float -> . INTEGER . INTEGER

    INTEGER         shift and go to state 16

    float                          shift and go to state 21

state 18

    (8) time -> INTEGER : INTEGER .

    $end            reduce using rule 8 (time -> INTEGER : INTEGER .)
    CPU             reduce using rule 8 (time -> INTEGER : INTEGER .)
    ALL             reduce using rule 8 (time -> INTEGER : INTEGER .)
    INTEGER         reduce using rule 8 (time -> INTEGER : INTEGER .)


state 19

    (9) date -> INTEGER / INTEGER . / INTEGER time

    /               shift and go to state 22


state 20

    (13) float -> INTEGER . . INTEGER

    INTEGER         shift and go to state 23


state 21

    (12) data -> time INTEGER float float . float float float float float float float
    (13) float -> . INTEGER . INTEGER

    INTEGER         shift and go to state 16

    float                          shift and go to state 24

state 22

    (9) date -> INTEGER / INTEGER / . INTEGER time

    INTEGER         shift and go to state 25


state 23

    (13) float -> INTEGER . INTEGER .

    INTEGER         reduce using rule 13 (float -> INTEGER . INTEGER .)
    $end            reduce using rule 13 (float -> INTEGER . INTEGER .)


state 24

    (12) data -> time INTEGER float float float . float float float float float float
    (13) float -> . INTEGER . INTEGER

    INTEGER         shift and go to state 16

    float                          shift and go to state 26

state 25

    (9) date -> INTEGER / INTEGER / INTEGER . time
    (8) time -> . INTEGER : INTEGER

    INTEGER         shift and go to state 27

    time                           shift and go to state 28

state 26

    (12) data -> time INTEGER float float float float . float float float float float
    (13) float -> . INTEGER . INTEGER

    INTEGER         shift and go to state 16

    float                          shift and go to state 29

state 27

    (8) time -> INTEGER . : INTEGER

    :               shift and go to state 14


state 28

    (9) date -> INTEGER / INTEGER / INTEGER time .

    $end            reduce using rule 9 (date -> INTEGER / INTEGER / INTEGER time .)


state 29

    (12) data -> time INTEGER float float float float float . float float float float
    (13) float -> . INTEGER . INTEGER

    INTEGER         shift and go to state 16

    float                          shift and go to state 30

state 30

    (12) data -> time INTEGER float float float float float float . float float float
    (13) float -> . INTEGER . INTEGER

    INTEGER         shift and go to state 16

    float                          shift and go to state 31

state 31

    (12) data -> time INTEGER float float float float float float float . float float
    (13) float -> . INTEGER . INTEGER

    INTEGER         shift and go to state 16

    float                          shift and go to state 32

state 32

    (12) data -> time INTEGER float float float float float float float float . float
    (13) float -> . INTEGER . INTEGER

    INTEGER         shift and go to state 16

    float                          shift and go to state 33

state 33

    (12) data -> time INTEGER float float float float float float float float float .

    $end            reduce using rule 12 (data -> time INTEGER float float float float float float float float float .)

